var fe=Object.defineProperty;var ue=(t,e,s)=>e in t?fe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s;var A=(t,e,s)=>ue(t,typeof e!="symbol"?e+"":e,s);import{p as J,_ as ve}from"../chunks/BCadlSJ_.js";import{f as R,a as L}from"../chunks/Dvt7mzJo.js";import"../chunks/Bdruw0Mz.js";import{o as Q}from"../chunks/VcqZ7kEe.js";import{a0 as he,a7 as pe,T as G,a2 as E,M as me,U as ge,g as T,q as _e,a9 as be,aa as we,ab as U,R as W,V as z,W as ye,ac as $,a1 as ee,ad as xe,am as B,_ as se,J as V,an as Se,C as te,ao as X,H as ke,ap as Ee,aq as De,Z as Ae,ar as Te,as as Ce,at as Ie,au as Me,O as ze,av as Oe,aw as Pe,ax as Ge,ay as We,p as ae,az as Be,aA as Ne,t as Y,j as ie,x as Le,e as Re,m as v,k as h,s as w,aB as qe}from"../chunks/BOemtITd.js";import{i as re}from"../chunks/zxLQ2OIY.js";import{s as K}from"../chunks/9qKrJ915.js";import"../chunks/0U86_LJp.js";function Fe(t,e){return e}function He(t,e,s,a){for(var r=[],o=e.length,n=0;n<o;n++)De(e[n].e,r,!0);var d=o>0&&r.length===0&&s!==null;if(d){var p=s.parentNode;Ae(p),p.append(s),a.clear(),C(t,e[0].prev,e[o-1].next)}Te(r,()=>{for(var g=0;g<o;g++){var i=e[g];d||(a.delete(i.k),C(t,i.prev,i.next)),Ce(i.e,!d)}})}function Je(t,e,s,a,r,o=null){var n=t,d={flags:e,items:new Map,first:null};{var p=t;n=E?G(me(p)):p.appendChild(he())}E&&ge();var g=null,i=!1,_=_e(()=>{var l=s();return ke(l)?l:l==null?[]:se(l)});pe(()=>{var l=T(_),u=l.length;if(i&&u===0)return;i=u===0;let c=!1;if(E){var S=be(n)===we;S!==(u===0)&&(n=U(),G(n),W(!1),c=!0)}if(E){for(var b=null,f,m=0;m<u;m++){if(z.nodeType===8&&z.data===ye){n=z,c=!0,W(!1);break}var k=l[m],y=a(k,m);f=oe(z,d,b,null,k,y,m,r,e,s),d.items.set(y,f),b=f}u>0&&G(U())}E||Ue(l,d,n,r,e,a,s),o!==null&&(u===0?g?$(g):g=ee(()=>o(n)):g!==null&&xe(g,()=>{g=null})),c&&W(!0),T(_)}),E&&(n=z)}function Ue(t,e,s,a,r,o,n){var d=t.length,p=e.items,g=e.first,i=g,_,l=null,u=[],c=[],S,b,f,m;for(m=0;m<d;m+=1){if(S=t[m],b=o(S,m),f=p.get(b),f===void 0){var k=i?i.e.nodes_start:s;l=oe(k,e,l,l===null?e.first:l.next,S,b,m,a,r,n),p.set(b,l),u=[],c=[],i=l.next;continue}if(Ve(f,S,m),(f.e.f&B)!==0&&$(f.e),f!==i){if(_!==void 0&&_.has(f)){if(u.length<c.length){var y=c[0],x;l=y.prev;var D=u[0],I=u[u.length-1];for(x=0;x<u.length;x+=1)Z(u[x],y,s);for(x=0;x<c.length;x+=1)_.delete(c[x]);C(e,D.prev,I.next),C(e,l,D),C(e,I,y),i=y,l=I,m-=1,u=[],c=[]}else _.delete(f),Z(f,i,s),C(e,f.prev,f.next),C(e,f,l===null?e.first:l.next),C(e,l,f),l=f;continue}for(u=[],c=[];i!==null&&i.k!==b;)(i.e.f&B)===0&&(_??(_=new Set)).add(i),c.push(i),i=i.next;if(i===null)continue;f=i}u.push(f),l=f,i=f.next}if(i!==null||_!==void 0){for(var M=_===void 0?[]:se(_);i!==null;)(i.e.f&B)===0&&M.push(i),i=i.next;var P=M.length;if(P>0){var O=d===0?s:null;He(e,M,O,p)}}V.first=e.first&&e.first.e,V.last=l&&l.e}function Ve(t,e,s,a){Se(t.v,e),t.i=s}function oe(t,e,s,a,r,o,n,d,p,g){var i=(p&Ie)!==0,_=(p&Me)===0,l=i?_?te(r):X(r):r,u=(p&Ee)===0?n:X(n),c={i:u,v:l,k:o,a:null,e:null,prev:s,next:a};try{return c.e=ee(()=>d(t,l,u,g),E),c.e.prev=s&&s.e,c.e.next=a&&a.e,s===null?e.first=c:(s.next=c,s.e.next=c.e),a!==null&&(a.prev=c,a.e.prev=c.e),c}finally{}}function Z(t,e,s){for(var a=t.next?t.next.e.nodes_start:s,r=e?e.e.nodes_start:s,o=t.e.nodes_start;o!==a;){var n=ze(o);r.before(o),o=n}}function C(t,e,s){e===null?t.first=s:(e.next=s,e.e.next=s&&s.e),s!==null&&(s.prev=e,s.e.prev=e&&e.e)}function Xe(t,e,s){var a=t==null?"":""+t;return a===""?null:a}function Ye(t,e,s,a,r,o){var n=t.__className;if(E||n!==s||n===void 0){var d=Xe(s);(!E||d!==t.getAttribute("class"))&&(d==null?t.removeAttribute("class"):t.className=d),t.__className=s}return o}const Ke=Symbol("is custom element"),Ze=Symbol("is html");function N(t,e,s,a){var r=je(t);E&&(r[e]=t.getAttribute(e),e==="src"||e==="srcset"||e==="href"&&t.nodeName==="LINK")||r[e]!==(r[e]=s)&&(e==="loading"&&(t[Oe]=s),s==null?t.removeAttribute(e):typeof s!="string"&&Qe(t).includes(e)?t[e]=s:t.setAttribute(e,s))}function je(t){return t.__attributes??(t.__attributes={[Ke]:t.nodeName.includes("-"),[Ze]:t.namespaceURI===Pe})}var j=new Map;function Qe(t){var e=j.get(t.nodeName);if(e)return e;j.set(t.nodeName,e=[]);for(var s,a=t,r=Element.prototype;r!==a;){s=We(a);for(var o in s)s[o].set&&e.push(o);a=Ge(a)}return e}class $e{constructor(e){A(this,"container");A(this,"beforeEl");A(this,"beforeInsetEl");A(this,"afterTextEl");A(this,"handleEl");A(this,"onTouchMove",e=>{const s=this.container.offsetWidth,a=e.changedTouches[0].clientX,r=this.container.offsetLeft,o=a-r;if(o>10&&o<s-10){const n=o*100/s;this.beforeEl.style.width=`${n}%`,this.afterTextEl.style.zIndex="1",this.handleEl.style.left=`${n}%`}});A(this,"onMouseMove",e=>{const s=this.container.offsetWidth,a=e.offsetX;if(a>10&&a<s-10){const r=a*100/s;this.beforeEl.style.width=`${r}%`,this.afterTextEl.style.zIndex="1",this.handleEl.style.left=`${r}%`}});const{id:s}=e,a=document.querySelector(s);if(!a){console.warn(`BeforeAfter: container ${s} not found.`);return}this.container=a;const r=a.querySelector(".bal-before"),o=a.querySelector(".bal-before-inset"),n=a.querySelector(".bal-afterPosition"),d=a.querySelector(".bal-handle");if(!r||!o||!n||!d){console.warn(`BeforeAfter: one of the required sub-elements is missing inside ${s}.`);return}this.beforeEl=r,this.beforeInsetEl=o,this.afterTextEl=n,this.handleEl=d,this.updateBeforeInsetWidth(),window.addEventListener("resize",()=>this.updateBeforeInsetWidth()),this.beforeEl.style.width="50%",this.handleEl.style.left="50%",a.addEventListener("touchstart",p=>{a.addEventListener("touchmove",this.onTouchMove)}),a.addEventListener("mousemove",this.onMouseMove)}updateBeforeInsetWidth(){const e=this.container.offsetWidth;this.beforeInsetEl.style.width=`${e}px`}}var es=R('<div class="relative small-bal-container bg-white rounded shadow overflow-hidden"><div class="bal-wrapper"><div class="bal-after"><img alt="After image" class="img-fluid w-full h-auto block"/> <div class="bal-afterPosition afterLabel"> </div></div> <div class="bal-before"><div class="bal-before-inset"><img alt="Before image" class="img-fluid w-full h-auto block"/> <div class="bal-beforePosition beforeLabel"> </div></div></div>  <div class="bal-handle" style="left: 50%;"><div class="handle-left-arrow"></div> <div class="handle-right-arrow"></div></div></div></div>'),ss=R("<div></div>");function ts(t,e){ae(e,!1);const s=te();let a=J(e,"comparisons",24,()=>[]),r=J(e,"columns",8,2);Q(()=>{a().forEach(n=>{new $e({id:`#${n.id}`})})}),Be(()=>Re(r()),()=>{Le(s,`grid-cols-${r()}`)}),Ne(),re();var o=ss();Je(o,5,a,Fe,(n,d)=>{let p=()=>T(d).id,g=()=>T(d).before,i=()=>T(d).after,_=()=>T(d).captionBefore,l=()=>T(d).captionAfter;var u=es(),c=h(u),S=h(c),b=h(S),f=w(b,2),m=h(f,!0);v(f),v(S);var k=w(S,2),y=h(k),x=h(y),D=w(x,2),I=h(D,!0);v(D),v(y),v(k),qe(2),v(c),v(u),Y(()=>{N(u,"id",p()),N(b,"src",i()),K(m,l()),N(x,"src",g()),K(I,_())}),L(n,u)}),v(o),Y(()=>Ye(o,1,`grid ${T(s)??""} gap-4`)),L(t,o),ie()}var as=R(`<main><section class="hero is-light"><div class="hero-body"><div class="container is-max-desktop"><div class="columns is-centered"><div class="column has-text-centered"><h1 class="title is-1">Meshtryoshka: Differentiable Mesh Rendering for Unbounded Scenes</h1> <div class="is-size-5"><span class="mr-4"><a href="https://orcid.org/0000-0002-1223-4475" target="_blank">David Charatan</a> <sup>* ¹</sup></span> <span class="mr-4"><a href="https://orcid.org/0009-0003-4982-6671" target="_blank">Daniel Xu</a> <sup>* ¹</sup></span> <span class="mr-4"><a href="https://orcid.org/0009-0005-5300-5475" target="_blank">Rick Szeliski</a> <sup>²</sup></span> <span class="mr-4"><a href="https://orcid.org/0009-0002-5829-2192" target="_blank">George Kopanas</a> <sup>³</sup></span> <span><a href="https://orcid.org/0000-0002-0107-5704" target="_blank">Vincent Sitzmann</a> <sup>¹</sup></span></div> <div class="is-size-5"><sup>*</sup> Denotes equal contribution</div> <div class="is-size-5 mb-4"><span class="mr-4"><sup>¹</sup> Massachusetts Institute of Technology</span> <span class="mr-4"><sup>²</sup> University of Washington</span> <span><sup>³</sup> Runway AI, Inc.</span></div> <div class="buttons is-centered"><a href="meshtryoshka.pdf" class="button is-dark is-rounded"><span class="icon"><i class="ai ai-arxiv"></i></span> <span>Arxiv</span></a> <a href="https://github.com/dcharatan/triangle-splatting" class="button is-dark is-rounded"><span class="icon"><i class="fab fa-github"></i></span> <span>Code</span></a> <a href="ours_render.zip" class="button is-dark is-rounded"><span class="icon"><i class="far fa-clipboard"></i></span> <span>Results (ZIP)</span></a></div></div></div></div></div></section> <section class="hero is-light is-small"><div class="hero-body"><div class="container"><h2 class="title is-3 has-text-centered mb-4">Videos</h2> <div id="trajectory-carousel" class="carousel results-carousel svelte-edt2w5"><div class="item svelte-edt2w5"><video class="is-fullwidth svelte-edt2w5" autoplay loop controls preload="metadata"><source src="final_videos/surface_1.5_DSC07956.JPG.mp4" type="video/mp4"/></video></div> <div class="item svelte-edt2w5"><video class="is-fullwidth svelte-edt2w5" autoplay loop controls preload="metadata"><source src="final_videos/surface_1.5__DSC9213.JPG.mp4" type="video/mp4"/></video></div> <div class="item svelte-edt2w5"><video class="is-fullwidth svelte-edt2w5" autoplay loop controls preload="metadata"><source src="final_videos/surface_0.2__DSC9056.JPG.mp4" type="video/mp4"/></video></div> <div class="item svelte-edt2w5"><video class="is-fullwidth svelte-edt2w5" autoplay loop controls preload="metadata"><source src="final_videos/surface_1.5__DSC8768.JPG.mp4" type="video/mp4"/></video></div></div></div></div></section> <section class="hero is-light is-small"><div class="hero-body"><div class="container"><h2 class="title is-3 has-text-centered mb-4">Optimization Progress</h2> <div id="opt-progress-carousel" class="carousel results-carousel svelte-edt2w5"><div class="item svelte-edt2w5"><video class="is-fullwidth svelte-edt2w5" autoplay loop controls preload="metadata"><source src="final_videos/_DSC8679.mp4" type="video/mp4"/></video></div> <div class="item svelte-edt2w5"><video class="is-fullwidth svelte-edt2w5" autoplay loop controls preload="metadata"><source src="final_videos/DSCF6017.mp4" type="video/mp4"/></video></div> <div class="item svelte-edt2w5"><video class="is-fullwidth svelte-edt2w5" autoplay loop controls preload="metadata"><source src="final_videos/_DSC9040.mp4" type="video/mp4"/></video></div> <div class="item svelte-edt2w5"><video class="is-fullwidth svelte-edt2w5" autoplay loop controls preload="metadata"><source src="final_videos/_DSC9293.mp4" type="video/mp4"/></video></div></div></div></div></section> <section class="section"><div class="container is-max-desktop"><div class="columns is-centered has-text-centered"><div class="column is-four-fifths"><h2 class="title is-3">Abstract</h2> <div class="content has-text-justified"><p>Differentiable rendering has emerged as a powerful approach for 3D reconstruction
                and novel view synthesis. Today, state-of-the-art differentiable rendering methods
                combine a variety of custom representations of 3D geometry and appearance with
                specialized renderers. However, most downstream tasks in computer graphics rely on
                3D meshes, which provide superior portability, allow for hardware-accelerated rendering,
                and are at the core of most computer graphics workflows. While prior work has attempted
                differentiable rendering with mesh representations, these approaches are limited to
                object-centric scenes and fail to reconstruct large-scale, unbounded scenes.</p> <p>In this work, we introduce <em>Meshtryoshka</em>, a novel mesh differentiable rendering
                framework that combines an off-the-shelf triangle rasterizer with a 3D representation
                that consists of nested mesh shells which resemble a matryoshka doll. In every forward
                pass, the mesh shells are extracted anew from a 3D signed distance function via
                iso-surface extraction, and the opacities for each vertex are computed as a function
                of signed distance. Each mesh shell is then rasterized independently, and the final
                image is created via alpha compositing. Crucially, mesh vertex positions are updated
                only indirectly via gradients that flow through the opacity values into the signed
                distance function, and hence, our method is compatible with off-the-shelf mesh renderers
                that need not be differentiable with respect to vertex positions.</p> <p>On object-centric scenes, our method performs competitively with surface-based differentiable
                rendering techniques. To the best of our knowledge, our method is the first differentiable
                mesh rendering method that scales to unbounded, real-world 3D scenes, where it yields
                high-quality novel view synthesis results approaching those of state-of-the-art, non-mesh
                methods. Our method suggests that it may be possible to solve the differentiable rendering
                problem without relying on specialized renderers, only using conventional tools from the
                computer graphics toolbox.</p></div></div></div></div></section> <section class="section"><div class="container" style="width: 80%; margin: 0 auto;"><div class="columns is-centered has-text-centered"><div class="column"><h2 class="title is-3">Overview</h2> <div class="content has-text-justified"><img src="figures/figure_overview/figure_overview.svg" alt="Teaser Figure" style="width: 100%; height: auto; display: block; margin-bottom: 2.5rem;"/> <p>We transform a standard <em>non-differentiable</em> triangle rasterizer into an effective 
                  triangle-based differentiable renderer via several key ideas. First, we parameterize scenes 
                  via cubic grids of signed distances and view-dependent colors. We apply differentiable
                  marching cubes on multiple level sets of the signed distance field, to extract a set of 
                  nested mesh shells---a <em>Meshtryoshka</em>---from a scene. Each shell is a mesh whose vertices
                  contain color features interpolated from the grid representation.</p> <img src="figures/figure_rendering/figure_rendering.svg" alt="Teaser Figure" style="width: 100%; height: auto; display: block; margin-bottom: 2.5rem;"/> <p>Second, we render these shells using a two-step pipeline of rasterization and deferred shading, 
                  which allows us to utilize an off-the-shelf rasterizers. A rasterizer computes for each pixel
                  the triangle ID and barycentric coordinates of the first ray-triangle intersection. 
                  While this operation is non-differentiable, it can be combined with differentiable image-space interpolation
                  to convert per-triangle-vertex values into differentiable per-pixel values.
                  We perform this process on each mesh shell independently, and then combine the results via alpha compositing,
                  using the signed distance values to compute per-shell opacities. As explained in our paper, this formulation
                  is a close approximation of rendering the shells using ray tracing, allowing for gradient-based optimization.</p> <img src="figures/figure_marching_cubes/figure_marching_cubes.svg" alt="Teaser Figure" style="width: 100%; height: auto; display: block; margin-bottom: 2.5rem;"/> <p>Finally, to scale to real-world scenes, we use a mask to only store parameters in regions
                  occupied by shells. To handle this, we implement the differentiable marching cubes
                  that works on a sparse grid. We optimize coarse to fine, starting from a dense grid at
                  low resolution. At a fixed
                  interval, we prune and subdivide the grid by marking all voxels
                  that contribute to triangles on the zero level set, dilating, and upscaling
                  to form the new active grid. After
                  extracting a new set of vertices for the upscaled active grid, we 
                  trilinearly interpolate the previous subdivision
                  level's signed distance and spherical harmonics values.

                  We divide real-world scenes into foreground and background. The foreground
                  is represented as a regular 3D grid, while the background is represented
                  as a set of six truncated frustums resembling a tesseract in 3D. Each frustum
                  composes of frustum-shaped voxels which naturally are larger in proportion to the distance
                  from the scene center, ensuring that farther regions are represented
                  more sparsely.</p></div></div></div></div></section> <section class="section"><div class="container is-fluid"><h2 class="title is-3 has-text-centered mb-4">Image Comparisons</h2> <!></div></section></main>`,2);function vs(t,e){ae(e,!1);const s=[{id:"comp1",before:"3dgs_results/stump/test/ours_30000/renders/_DSC9221.png",after:"ours_render/stump/_DSC9221.JPG",captionBefore:"3D Gaussian Splatting",captionAfter:"Meshtryoshka (Ours)"},{id:"comp2",before:"3dgs_results/bicycle/test/ours_30000/renders/_DSC8752.png",after:"ours_render/bicycle/_DSC8752.JPG",captionBefore:"3D Gaussian Splatting",captionAfter:"Meshtryoshka (Ours)"},{id:"comp3",before:"3dgs_results/bonsai/test/ours_30000/renders/DSCF5605.png",after:"ours_render/bonsai/DSCF5605.JPG",captionBefore:"3D Gaussian Splatting",captionAfter:"Meshtryoshka (Ours)"},{id:"comp4",before:"3dgs_results/garden/test/ours_30000/renders/DSC08084.png",after:"ours_render/garden/DSC08084.JPG",captionBefore:"3D Gaussian Splatting",captionAfter:"Meshtryoshka (Ours)"},{id:"comp5",before:"3dgs_results/room/test/ours_30000/renders/DSCF4675.png",after:"ours_render/room/DSCF4675.JPG",captionBefore:"3D Gaussian Splatting",captionAfter:"Meshtryoshka (Ours)"},{id:"comp6",before:"3dgs_results/kitchen/test/ours_30000/renders/DSCF0664.png",after:"ours_render/kitchen/DSCF0664.JPG",captionBefore:"3D Gaussian Splatting",captionAfter:"Meshtryoshka (Ours)"}];Q(async()=>{const H=(await ve(async()=>{const{default:de}=await import("../chunks/DjY89ImB.js").then(ce=>ce.b);return{default:de}},[],import.meta.url)).default;H.attach("#trajectory-carousel",{slidesToScroll:1,slidesToShow:3,infinite:!0,autoplay:!1,pauseOnHover:!0}),H.attach("#opt-progress-carousel",{slidesToScroll:1,slidesToShow:3,infinite:!0,autoplay:!1,pauseOnHover:!0})}),re();var a=as(),r=w(h(a),2),o=h(r),n=h(o),d=w(h(n),2),p=h(d),g=h(p);g.muted=!0,v(p);var i=w(p,2),_=h(i);_.muted=!0,v(i);var l=w(i,2),u=h(l);u.muted=!0,v(l);var c=w(l,2),S=h(c);S.muted=!0,v(c),v(d),v(n),v(o),v(r);var b=w(r,2),f=h(b),m=h(f),k=w(h(m),2),y=h(k),x=h(y);x.muted=!0,v(y);var D=w(y,2),I=h(D);I.muted=!0,v(D);var M=w(D,2),P=h(M);P.muted=!0,v(M);var O=w(M,2),ne=h(O);ne.muted=!0,v(O),v(k),v(m),v(f),v(b);var q=w(b,6),F=h(q),le=w(h(F),2);ts(le,{get comparisons(){return s},columns:"2"}),v(F),v(q),v(a),L(t,a),ie()}export{vs as component};
